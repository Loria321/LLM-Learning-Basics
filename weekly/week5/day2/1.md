### 需求复述
你需要开发一款结构化数据清洗工具，核心能力是支持 CSV/JSON/Excel 多格式数据输入，经过数据清洗、规则校验后，输出符合大模型微调格式的 JSONL 文件，并且计划用电商商品数据完成该工具的测试验证。

### 工具开发实现
#### 技术选型
选择 Python 作为开发语言（生态丰富、易用性高），核心依赖库：
- `pandas`：处理结构化数据的核心库，支持多格式读取/写入
- `openpyxl`：读取 Excel (.xlsx) 文件
- `jsonlines`：高效写入 JSONL 格式文件
- `typing`：类型提示，提升代码可读性

#### 完整代码实现
```python
import os
import pandas as pd
import jsonlines
from typing import Dict, List, Tuple, Optional

# ====================== 1. 多格式数据读取模块 ======================
def read_structured_data(file_path: str) -> Optional[pd.DataFrame]:
    """
    统一读取函数：根据文件后缀自动识别格式，读取为DataFrame
    :param file_path: 输入文件路径
    :return: 结构化数据DataFrame / None（读取失败）
    """
    # 校验文件是否存在
    if not os.path.exists(file_path):
        print(f"错误：文件 {file_path} 不存在")
        return None
    
    # 提取文件后缀
    file_suffix = os.path.splitext(file_path)[-1].lower()
    
    try:
        if file_suffix == ".csv":
            df = pd.read_csv(file_path, encoding="utf-8")
        elif file_suffix == ".json":
            df = pd.read_json(file_path, encoding="utf-8")
        elif file_suffix in [".xlsx", ".xls"]:
            df = pd.read_excel(file_path, engine="openpyxl")
        else:
            print(f"错误：不支持的文件格式 {file_suffix}")
            return None
        print(f"成功读取 {file_path}，数据行数：{len(df)}")
        return df
    except Exception as e:
        print(f"读取文件失败：{str(e)}")
        return None

# ====================== 2. 数据清洗模块 ======================
def clean_ecommerce_data(df: pd.DataFrame) -> pd.DataFrame:
    """
    电商商品数据清洗逻辑（可根据业务扩展）
    核心清洗规则：
    1. 删除完全重复的行
    2. 缺失值处理：必填字段缺失则删除行，非必填字段填充默认值
    3. 异常值过滤：价格/库存非负、销量为整数
    4. 字段标准化：统一字段名（如"商品名称"→"product_name"）
    """
    # 字段名标准化（适配大模型微调的字段命名习惯）
    field_mapping = {
        "商品名称": "product_name",
        "商品价格": "price",
        "商品库存": "stock",
        "商品销量": "sales",
        "商品分类": "category",
        "商品描述": "description"
    }
    df.rename(columns=field_mapping, inplace=True)
    
    # 1. 删除完全重复行
    df = df.drop_duplicates()
    
    # 2. 缺失值处理：必填字段（product_name/price/category）缺失则删除行
    required_fields = ["product_name", "price", "category"]
    df = df.dropna(subset=required_fields)
    
    # 非必填字段缺失填充
    df["stock"] = df["stock"].fillna(0)  # 库存默认0
    df["sales"] = df["sales"].fillna(0)  # 销量默认0
    df["description"] = df["description"].fillna("无描述")  # 描述默认值
    
    # 3. 异常值过滤
    df = df[df["price"] >= 0]  # 价格非负
    df = df[df["stock"] >= 0]  # 库存非负
    df["sales"] = pd.to_numeric(df["sales"], errors="coerce").fillna(0).astype(int)  # 销量转为整数
    
    print(f"数据清洗完成，剩余数据行数：{len(df)}")
    return df

# ====================== 3. 数据校验模块 ======================
def validate_ecommerce_data(df: pd.DataFrame) -> Tuple[bool, List[str]]:
    """
    电商商品数据校验：检查字段类型、业务规则
    :return: (校验是否通过, 错误信息列表)
    """
    errors = []
    
    # 1. 字段类型校验
    if not pd.api.types.is_string_dtype(df["product_name"]):
        errors.append("product_name 字段必须为字符串类型")
    if not pd.api.types.is_numeric_dtype(df["price"]):
        errors.append("price 字段必须为数值类型")
    if not pd.api.types.is_integer_dtype(df["stock"]):
        df["stock"] = df["stock"].astype(int)  # 自动修正
    
    # 2. 业务规则校验
    if df[df["price"] > 100000].shape[0] > 0:
        errors.append(f"发现 {df[df['price'] > 100000].shape[0]} 条价格异常（>10万）的数据")
    
    # 3. 字段长度校验（避免大模型输入过长）
    df["product_name"] = df["product_name"].str[:100]  # 商品名最长100字符
    df["description"] = df["description"].str[:500]  # 描述最长500字符
    
    is_valid = len(errors) == 0
    if not is_valid:
        print("数据校验发现以下问题：")
        for err in errors:
            print(f"- {err}")
    else:
        print("数据校验通过")
    return is_valid, errors

# ====================== 4. JSONL格式转换与输出模块 ======================
def convert_to_finetune_jsonl(df: pd.DataFrame, output_path: str) -> bool:
    """
    将清洗后的电商数据转换为大模型微调的JSONL格式（prompt-completion结构）
    :param df: 清洗后的DataFrame
    :param output_path: JSONL输出路径
    :return: 是否输出成功
    """
    # 大模型微调格式：prompt（指令）+ completion（回答）
    finetune_data = []
    for _, row in df.iterrows():
        prompt = f"请介绍这款商品：{row['product_name']}（分类：{row['category']}）"
        completion = f"""
商品名称：{row['product_name']}
分类：{row['category']}
价格：{row['price']} 元
库存：{row['stock']} 件
销量：{row['sales']} 件
描述：{row['description']}
        """.strip()
        
        finetune_data.append({
            "prompt": prompt,
            "completion": completion
        })
    
    # 写入JSONL文件
    try:
        with jsonlines.open(output_path, mode="w", encoding="utf-8") as writer:
            writer.write_all(finetune_data)
        print(f"成功输出JSONL文件：{output_path}，共 {len(finetune_data)} 条数据")
        return True
    except Exception as e:
        print(f"输出JSONL失败：{str(e)}")
        return False

# ====================== 5. 主流程函数 ======================
def ecommerce_data_clean_pipeline(input_file: str, output_file: str) -> bool:
    """
    电商数据清洗完整流程：读取→清洗→校验→输出JSONL
    """
    # 步骤1：读取数据
    df = read_structured_data(input_file)
    if df is None:
        return False
    
    # 步骤2：数据清洗
    df_cleaned = clean_ecommerce_data(df)
    if df_cleaned.empty:
        print("错误：清洗后无数据")
        return False
    
    # 步骤3：数据校验
    is_valid, _ = validate_ecommerce_data(df_cleaned)
    if not is_valid:
        print("警告：数据校验未通过，但仍尝试输出（可根据业务调整是否终止）")
    
    # 步骤4：输出JSONL
    return convert_to_finetune_jsonl(df_cleaned, output_file)

# ====================== 测试用例 ======================
if __name__ == "__main__":
    # 模拟电商商品数据（可替换为真实文件路径）
    test_data = {
        "商品名称": ["华为Mate60 Pro", "苹果iPhone15", "小米14", None, "华为Mate60 Pro"],
        "商品价格": [6999, 5999, -3999, 4999, 6999],  # 包含异常值
        "商品库存": [1000, 2000, 1500, None, 1000],
        "商品销量": [5000, 8000, "6000", 7000, 5000],  # 包含字符串类型
        "商品分类": ["手机", "手机", "手机", "手机", "手机"],
        "商品描述": ["鸿蒙系统，卫星通话", None, "骁龙8Gen3，徕卡影像", "", "鸿蒙系统，卫星通话"]
    }
    
    # 生成测试CSV文件（也可生成JSON/Excel测试）
    test_csv_path = "test_ecommerce_data.csv"
    pd.DataFrame(test_data).to_csv(test_csv_path, index=False, encoding="utf-8")
    
    # 执行清洗流程
    output_jsonl_path = "finetune_ecommerce_data.jsonl"
    result = ecommerce_data_clean_pipeline(test_csv_path, output_jsonl_path)
    
    if result:
        print("\n测试完成！输出文件：", output_jsonl_path)
        # 读取输出的JSONL验证
        with jsonlines.open(output_jsonl_path, encoding="utf-8") as reader:
            for i, line in enumerate(reader):
                if i < 2:  # 打印前2条验证
                    print(f"\n第{i+1}条微调数据：")
                    print(f"Prompt: {line['prompt']}")
                    print(f"Completion: {line['completion']}")
    else:
        print("测试失败")
```

#### 代码关键说明
1. **多格式读取**：`read_structured_data` 函数通过文件后缀自动识别 CSV/JSON/Excel，封装了统一的读取逻辑，降低调用复杂度。
2. **数据清洗**：针对电商场景定制规则（如价格非负、必填字段校验、字段名标准化），兼顾通用性和业务适配性。
3. **数据校验**：不仅检查字段类型，还加入业务规则（如价格上限），并自动修正轻微异常（如库存类型转换）。
4. **JSONL输出**：适配大模型微调的 `prompt-completion` 结构，Prompt 为指令，Completion 为标准化的商品信息，符合大模型训练数据格式要求。
5. **环境依赖安装**：
```bash
pip install pandas openpyxl jsonlines
```

### 总结
1. 工具核心采用**分层设计**（读取-清洗-校验-输出），模块化强，可根据不同业务场景（如零售、金融）替换清洗/校验规则。
2. 多格式处理依赖 pandas 原生能力，通过文件后缀自动识别，无需手动指定格式，提升易用性。
3. 数据清洗和校验需**贴合业务场景**：电商数据重点处理价格/库存异常、必填字段缺失，输出格式适配大模型微调的 JSONL 结构。
4. 测试用例包含异常数据（缺失值、负数、重复值），可验证工具的容错和清洗能力，替换为真实电商数据即可直接使用。
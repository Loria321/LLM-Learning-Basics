### 1. 需求确认
你想要系统学习多格式数据处理的核心技能，重点掌握 `pandas` 读取 JSON/Excel 数据的方法、用 `json_normalize` 展开 JSON 嵌套字段，并通过实操完成**含嵌套“规格”字段的电商商品 JSON 数据清洗**，形成从数据读取→嵌套解析→清洗→输出的完整流程。


### 2. 多格式数据处理核心知识 + 实操（电商商品场景）
#### 2.1 基础准备：环境与依赖
确保安装必备库（已安装可跳过）：
```bash
pip install pandas openpyxl -i https://pypi.tuna.tsinghua.edu.cn/simple
```
- `pandas`：核心数据处理库（支持 JSON/Excel 读写、嵌套解析）；
- `openpyxl`：支持 Excel 文件读写（pandas 依赖此库处理 .xlsx）。

#### 2.2 核心知识点1：JSON/Excel 数据读取（pd.read_json/pd.read_excel）
| 方法                | 作用                | 核心参数（新手必看）|
|---------------------|---------------------|-----------------------------------|
| `pd.read_json()`    | 读取 JSON 数据      | `path_or_buf`：文件路径/JSON 字符串；`orient`：JSON 结构（常用`records`，对应列表套字典）；`encoding`：编码（如`utf-8`） |
| `pd.read_excel()`   | 读取 Excel 数据     | `io`：文件路径；`sheet_name`：工作表名（默认0，即第一个）；`header`：表头行（默认0）；`usecols`：指定读取列 |

**简单示例**：
```python
import pandas as pd

# 1. 读取JSON文件（假设文件为 goods_raw.json）
df_json = pd.read_json("goods_raw.json", orient="records", encoding="utf-8")

# 2. 读取Excel文件（假设文件为 goods_raw.xlsx）
df_excel = pd.read_excel("goods_raw.xlsx", sheet_name="商品数据", usecols=["商品ID", "商品名称", "价格"])

print("JSON读取结果：\n", df_json.head(1))
print("Excel读取结果：\n", df_excel.head(1))
```

#### 2.3 核心知识点2：JSON 嵌套数据处理（json_normalize）
电商数据常出现**嵌套字典/列表**（如“规格”字段是嵌套字典），`pandas.json_normalize()` 是解析嵌套 JSON 的核心工具，能将嵌套字段“平铺”为列。

| 核心参数          | 作用                                                                 |
|-------------------|----------------------------------------------------------------------|
| `data`            | 待解析的 JSON 数据（列表套字典）|
| `record_path`     | 指定嵌套列表的路径（如`["规格", "颜色"]`，解析嵌套列表）|
| `meta`            | 保留顶层字段（如`["商品ID", "商品名称"]`，避免解析嵌套后丢失顶层信息） |
| `sep`             | 嵌套字段的列名分隔符（如`_`，嵌套字段会变成`规格_颜色`）|

**核心逻辑**：
```python
from pandas import json_normalize

# 假设有嵌套JSON数据
nested_data = [
    {
        "商品ID": 1001,
        "商品名称": "纯棉T恤",
        "规格": {"颜色": "白色", "尺码": "M", "库存": 100}  # 嵌套字典
    },
    {
        "商品ID": 1002,
        "商品名称": "运动鞋",
        "规格": [{"颜色": "黑色", "尺码": "42", "库存": 50}, {"颜色": "白色", "尺码": "43", "库存": 30}]  # 嵌套列表
    }
]

# 解析嵌套字典（平铺为列）
df_normalize1 = json_normalize(nested_data, sep="_")
print("解析嵌套字典：\n", df_normalize1)

# 解析嵌套列表（需指定record_path和meta）
df_normalize2 = json_normalize(
    nested_data,
    record_path=["规格"],  # 嵌套列表的路径
    meta=["商品ID", "商品名称"],  # 保留顶层字段
    sep="_"
)
print("\n解析嵌套列表：\n", df_normalize2)
```

#### 2.4 实操：电商商品 JSON 数据完整清洗流程
##### 步骤1：构造测试数据（模拟真实电商 JSON 数据）
新建 `goods_raw.json` 文件，粘贴以下内容（含嵌套“规格”字段、噪声、缺值）：
```json
[
    {"商品ID": 1001, "商品名称": "纯棉短袖T恤", "价格": 59.9, "品牌": "优衣库", "规格": {"颜色": "白色", "尺码": "M", "库存": 100, "材质": "100%棉"}, "上架时间": "2025-01-01", "销量": 2000},
    {"商品ID": 1002, "商品名称": "夏季休闲裤", "价格": 89.9, "品牌": "", "规格": {"颜色": "藏青", "尺码": "L", "库存": 50, "材质": "聚酯纤维"}, "上架时间": "", "销量": 800},
    {"商品ID": 1003, "商品名称": "运动鞋", "价格": 299.9, "品牌": "耐克", "规格": [{"颜色": "黑色", "尺码": "42", "库存": 50}, {"颜色": "白色", "尺码": "43", "库存": 30}], "上架时间": "2025-01-10", "销量": 1500},
    {"商品ID": 1004, "商品名称": "纯棉短袖T恤", "价格": 59.9, "品牌": "优衣库", "规格": {"颜色": "白色", "尺码": "M", "库存": 100, "材质": "100%棉"}, "上架时间": "2025-01-01", "销量": 2000},
    {"商品ID": 1005, "商品名称": "", "价格": "", "品牌": "阿迪达斯", "规格": {"颜色": "红色", "尺码": "XL", "库存": -5, "材质": "涤纶"}, "上架时间": "2025-01-15", "销量": 0}
]
```

##### 步骤2：完整清洗代码（读取→解析嵌套→清洗→输出）
```python
import pandas as pd
from pandas import json_normalize
import json

# ===================== 步骤1：读取JSON数据 =====================
def read_json_data(file_path):
    """读取JSON文件，处理编码和格式问题"""
    try:
        # 方式1：直接用pd.read_json（适合标准JSON）
        df = pd.read_json(file_path, orient="records", encoding="utf-8")
        print(f"✅ 读取JSON成功，原始数据量：{len(df)} 条")
        return df
    except Exception as e:
        # 方式2：手动读取JSON字符串（兼容非标准格式）
        with open(file_path, "r", encoding="utf-8") as f:
            data = json.load(f)
        df = pd.DataFrame(data)
        print(f"✅ 手动读取JSON成功，原始数据量：{len(df)} 条")
        return df

# ===================== 步骤2：解析嵌套的“规格”字段 =====================
def parse_nested_spec(df):
    """解析嵌套的规格字段（兼容字典/列表两种嵌套形式）"""
    # 拆分两种嵌套类型：规格是字典 / 规格是列表
    df_dict = df[df["规格"].apply(lambda x: isinstance(x, dict))].copy()
    df_list = df[df["规格"].apply(lambda x: isinstance(x, list))].copy()
    
    # 解析字典型规格（直接平铺）
    df_dict_normalize = json_normalize(df_dict.to_dict("records"), sep="_")
    
    # 解析列表型规格（指定record_path和meta）
    if not df_list.empty:
        df_list_normalize = json_normalize(
            df_list.to_dict("records"),
            record_path=["规格"],  # 嵌套列表的路径
            meta=["商品ID", "商品名称", "价格", "品牌", "上架时间", "销量"],  # 保留顶层字段
            sep="_"
        )
    else:
        df_list_normalize = pd.DataFrame()
    
    # 合并两种类型的解析结果
    df_parsed = pd.concat([df_dict_normalize, df_list_normalize], ignore_index=True)
    print(f"✅ 解析嵌套规格成功，解析后数据量：{len(df_parsed)} 条")
    return df_parsed

# ===================== 步骤3：数据清洗（去重/缺值/格式标准化） =====================
def clean_goods_data(df):
    """电商商品数据清洗：去重、补全缺值、格式校验"""
    # 1. 去重（根据商品ID+规格_颜色+规格_尺码去重）
    df = df.drop_duplicates(subset=["商品ID", "规格_颜色", "规格_尺码"], keep="first")
    print(f"🔍 去重后数据量：{len(df)} 条")
    
    # 2. 处理缺值（核心字段补全/过滤）
    # 过滤商品名称为空的无效数据
    df = df[df["商品名称"].notna() & (df["商品名称"].str.strip() != "")]
    # 价格缺值填充为0，转为浮点数
    df["价格"] = pd.to_numeric(df["价格"], errors="coerce").fillna(0.0)
    # 品牌缺值填充为“未知品牌”
    df["品牌"] = df["品牌"].fillna("未知品牌").replace("", "未知品牌")
    # 上架时间缺值填充为“未上架”
    df["上架时间"] = df["上架时间"].fillna("未上架").replace("", "未上架")
    
    # 3. 格式标准化
    # 库存校验：负数库存改为0
    df["规格_库存"] = pd.to_numeric(df["规格_库存"], errors="coerce").fillna(0)
    df.loc[df["规格_库存"] < 0, "规格_库存"] = 0
    # 销量标准化：转为整数
    df["销量"] = pd.to_numeric(df["销量"], errors="coerce").fillna(0).astype(int)
    
    # 4. 过滤无效数据（价格为0且销量为0的商品）
    df = df[~((df["价格"] == 0) & (df["销量"] == 0))]
    print(f"✅ 清洗完成，最终数据量：{len(df)} 条")
    return df

# ===================== 步骤4：保存为Excel/JSON（多格式输出） =====================
def save_cleaned_data(df, excel_path="goods_cleaned.xlsx", json_path="goods_cleaned.json"):
    """保存清洗后数据为Excel和JSON"""
    # 保存为Excel（支持多工作表）
    with pd.ExcelWriter(excel_path, engine="openpyxl") as writer:
        df.to_excel(writer, sheet_name="清洗后商品数据", index=False)
    print(f"📁 清洗后数据已保存至Excel：{excel_path}")
    
    # 保存为JSON（records格式，便于后续读取）
    df.to_json(json_path, orient="records", force_ascii=False, indent=2)
    print(f"📁 清洗后数据已保存至JSON：{json_path}")

# ===================== 主执行逻辑 =====================
if __name__ == "__main__":
    # 1. 读取原始JSON
    df_raw = read_json_data("goods_raw.json")
    
    # 2. 解析嵌套规格
    df_parsed = parse_nested_spec(df_raw)
    
    # 3. 数据清洗
    df_cleaned = clean_goods_data(df_parsed)
    
    # 4. 打印清洗结果预览
    print("\n📊 清洗后数据预览：")
    print(df_cleaned[["商品ID", "商品名称", "价格", "品牌", "规格_颜色", "规格_尺码", "规格_库存", "销量"]].head())
    
    # 5. 保存为Excel/JSON
    save_cleaned_data(df_cleaned)
```

##### 步骤3：运行结果解读
```
✅ 读取JSON成功，原始数据量：5 条
✅ 解析嵌套规格成功，解析后数据量：6 条（注：运动鞋的规格是列表，解析后拆分为2条）
🔍 去重后数据量：5 条（删除1条重复的T恤数据）
✅ 清洗完成，最终数据量：4 条（过滤1条名称/价格为空的无效商品）

📊 清洗后数据预览：
   商品ID    商品名称    价格   品牌 规格_颜色 规格_尺码  规格_库存    销量
0   1001  纯棉短袖T恤   59.9  优衣库      白色       M    100.0  2000
1   1002    夏季休闲裤   89.9  未知品牌      藏青       L     50.0   800
2   1003      运动鞋  299.9   耐克      黑色      42     50.0  1500
3   1003      运动鞋  299.9   耐克      白色      43     30.0  1500

📁 清洗后数据已保存至Excel：goods_cleaned.xlsx
📁 清洗后数据已保存至JSON：goods_cleaned.json
```

#### 2.5 扩展：读取/处理Excel格式的电商数据
如果原始数据是Excel（`goods_raw.xlsx`），只需修改读取函数为：
```python
def read_excel_data(file_path):
    """读取Excel格式的电商数据"""
    df = pd.read_excel(
        file_path,
        sheet_name="商品数据",
        usecols=["商品ID", "商品名称", "价格", "品牌", "规格", "上架时间", "销量"],
        encoding="utf-8"
    )
    # Excel中的“规格”字段若为字符串，需转为字典/列表
    df["规格"] = df["规格"].apply(lambda x: json.loads(x) if isinstance(x, str) else x)
    print(f"✅ 读取Excel成功，原始数据量：{len(df)} 条")
    return df
```


### 3. 核心知识点总结
#### 3.1 JSON/Excel 数据处理关键
1. `pd.read_json()` 适合读取标准JSON（列表套字典），`orient="records"` 是最常用参数；
2. `pd.read_excel()` 需指定 `sheet_name` 和 `usecols`，避免读取无关数据；
3. Excel中的嵌套字段（如字符串格式的JSON）需用 `json.loads()` 转为字典/列表。

#### 3.2 嵌套JSON解析核心
1. 嵌套**字典**：直接用 `json_normalize(data, sep="_")` 平铺为列；
2. 嵌套**列表**：需指定 `record_path`（嵌套列表路径）+ `meta`（保留顶层字段）；
3. `sep="_"` 可规范嵌套列名（如`规格_颜色`），避免列名混乱。

#### 3.3 电商数据清洗重点
1. 去重：需结合“商品ID+规格”（避免重复商品）；
2. 缺值处理：核心字段（名称/价格）过滤，非核心字段（品牌）填充默认值；
3. 格式校验：数值型字段（价格/库存/销量）转为数字，负数库存修正为0。

这套流程可直接复用至各类多格式数据处理场景（如物流数据、用户数据），仅需调整清洗规则和嵌套字段路径即可！